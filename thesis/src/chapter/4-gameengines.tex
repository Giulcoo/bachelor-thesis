\chapter{Game Engines}\label{ch:gameengines}
In diesem Kapitel soll die Theorie und Algorithmen aus den vorherigen Kapiteln 
getestet werden. Manche Game Engines bieten auch eigene Speichersysteme oder
Tools dafür, diese können hier auch getestet werden.

Gleiche Szene in verschiedenen Game Engines testen. 
Verschiedene Speichersysteme ausprobieren und wenn vorhanden über die von den Game Engines erzählen und ausprobieren.

Zu testende Game Engines: Unity, Unreal Engine, Godot

Szene zum testen soll sehr viele Daten zu speichern haben (Große Map und viele unterschiedliche Informationen)
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Unity}
Unity Engine grob vorstellen und erklären

% 10.7.
\url{https://blog.unity.com/games/persistent-data-how-to-save-your-game-states-and-settings}


\subsection{PlayerPrefs}
\begin{itemize}
    \item Einfachste Art Daten zu speichern, aber sehr limitiert
    \item Nur zum Speichern von string, float, integer
    \item Allgemein können nicht viele Daten gespeichert werden
    \item Daten werden beim schließen des Spieles abgespeichert (mit save Funktion kann das aber auch gezwungen werden)
    \item Je nach OS unterschiedliches Datei-Format
    \item Besser zum Speichern von Konfigurationen (Auflösung, Audio Device, ...)
    \item Ungeschützt
\end{itemize}

% 10.7.
\url{https://docs.unity3d.com/ScriptReference/PlayerPrefs.html}\\
\url{https://blog.logrocket.com/why-should-shouldnt-save-data-unitys-playerprefs/}

\subsection{JSON}

\begin{itemize}
    \item JsonUtility (Von Unity. Hat Einschränkungen, ist dafür aber schnell. Anwendungsbereich ausarbeiten)
    \item Json.NET (Newtonsoft)
    \item LitJSON (.Net Library)
\end{itemize}

JsonUtility:
\begin{itemize}
    \item "[Serializable]" vor Klassen/Strukturen, damit diese umgewandlet werden können (dürfen aber nicht static sein)
    \item public oder mit " [SerializeField]" gekenntzeichnette Variablen werden serialisiert
    \item JsonUtility.ToJson(obj) und JsonUtility.FromJson<T>(json) zum (de)serialisieren
    \item Manche Typen sind nicht unterstützt (Dictionary<>, Multidimensionale/Jagged Arrays, nested container Typen, ...)
    \item Nicht unterstützte Typen über implementierung von ISerializationCallbackReceiver serialisieren, mit custom Serialisierung
\end{itemize}

% 10.7.
\url{https://docs.unity3d.com/2020.1/Documentation/Manual/JSONSerialization.html}\\
\url{https://blog.logrocket.com/why-should-shouldnt-save-data-unitys-playerprefs/}\\
\url{https://docs.unity3d.com/2023.2/Documentation/Manual/script-Serialization.html}


Json.NET:
\begin{itemize}
    \item JSON Serialisierer um Umwandeln zwischen .NET-Objekten zu JSON zu ermöglichen 
    \item Typen die JsonUtility nicht unterstützt gehen hier
    \item Serialisiert alle public Attribute
    \item "[JsonIgnore]" um beim Serialisierer Attribute zu ignorieren
\end{itemize}

% 10.7.
\url{https://www.newtonsoft.com/json}\\
\url{https://www.newtonsoft.com/json/help/html/Performance.htm}\\

LitJSON:\\
% 10.7.
\url{https://litjson.net/}

\url{https://www.jacksondunstan.com/articles/3303}\\
\url{https://michaelscodingspot.com/the-battle-of-c-to-json-serializers-in-net-core-3/}

\subsection{BinaryFormatter}
Kurz erwähnen was BinaryFormatter macht und warum er nicht benutzt werden soll. Vielleicht mit einem Beispiel

\begin{itemize}
    \item Serialisieren von Objekten in ein langes stream im binären Format
    \item Serialize(File filename, Object object)
    \item Deserialize(File filename)
    \item Sicherheitsrisiken beim Deserialisieren:
    \begin{itemize}
        \item Angreifer kann ein Denial of Serivce (DoS), Veröffentlichung von Informationen oder Remoteausführung von Code in Ziel-App bewirken
        \item Deserialisieren von Daten mit BinaryFormatter bringt viele Risiken
        \item Angreifer kann Code im Kontext des Zielprozesses ausführen
    \end{itemize}
    \item Sicherere Alternative: BinaryReader und BinaryWriter
    \begin{itemize}
        \item Schreiben/Lesen von primitven Datentypen im binären Format
    \end{itemize}
\end{itemize}

% 10.7.
\url{https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=net-7.0}\\
\url{https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide}\\
\url{https://github.com/pwntester/ysoserial.net}

\subsection{StreamWriter}
\begin{itemize}
    \item Direktes Schreiben von Zeilen auf Dateien 
    \item Zum Lesen der Zeilen StreamReader
    \item Eignes Format zum Speichern der Klassen bestimmen
    \item Wenn Format geändert wird, kann es schwierig werden Dateien mit altem Format zu verwenden
\end{itemize}

% 10.7.
\url{https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter?view=net-7.0}

\subsection{Easy Save}

\begin{itemize}
    \item Unity Package, welches ein komplettes Speicher und Serialisier System ist
    \item ES3.Save(String key, Object value)
    \item ES3.Load<T>(String key, Object defaultValue)
    \item Klassenattribute werden gespeichert, wenn:
    \begin{itemize}
        \item public oder [SerializeField] Attribut haben
        \item Nicht const oder readonly
        \item Nicht [Obsolete] oder [NonSerialized] Attribut
        \item Verschlüsselung mit ES3Settings(ES3.EncryptionType encryptionType, String password)
        \item Komprimierung mit ES3Settings(ES3.CompressionType compressionType)
        \item Auto Save Funktion
    \end{itemize}
\end{itemize}
% 10.7.
\url{https://docs.moodkie.com/product/easy-save-3/}\\
\url{https://assetstore.unity.com/packages/tools/utilities/easy-save-the-complete-save-data-serializer-system-768}

\subsection{Component-Save-System}

\url{https://github.com/AlexMeesters/Component-Save-System}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Unreal Engine}
Unreal Engine grob vorstellen und erklären

\subsection{SaveGame Objekt}
Erklären was das ist, was benutzt wird und ein kleines Beispiel zeigen.

\begin{itemize}
    \item Blueprint zum Speichern/Laden der Daten
    \item Daten in .sav-Datei gespeichert (darüber recherchieren, was das ist und wie Daten hier gespeichert werden. Vor und Nachteile vielleicht auch nennen)
    \item Asynchrones/Syncrhones Speichern/Laden (bei großen Mengen von Daten ist asynchron besser)
\end{itemize}

% 10.7.
\url{https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/SaveGame/}\\
\url{https://www.tomlooman.com/unreal-engine-cpp-save-system/}

\subsection{JSON}

\begin{itemize}
    \item FJsonSerializer::Serialize((TSharedPtr<FJsonObject> object).ToSharedRef(), TJsonWriterFactory<>::Create(FString jsonString, 0))
    \item FJsonSerializer::Deserialize(TJsonReaderFactory<>::Create(String json), TSharedPtr<FJsonObject> object)
\end{itemize}
% 10.7.
\url{https://docs.unrealengine.com/4.27/en-US/API/Runtime/Json/Serialization/FJsonSerializer/}\\
\url{https://docs.unrealengine.com/4.27/en-US/API/Runtime/Json/Dom/FJsonObject/}

\subsection{Save Extension}

\begin{itemize}
    \item Blueprint zum Speichern/Laden einer Welt mit Slot ID
    \item Auswählen der Actors und Components, die gespeichert/geladen werden sollen über Filter
    \item Dateien können dann komprimiert werden
    \item Jeder Actor hat Save Settings (Sollen die Tags, Transform oder Physik des Actors gespeichert werden?)
    \item Jeder Actor, Component und Level hat ein "Record" = Block aus serialisierter Information
    \item Jeder Slot wird in einer Datei gespeichert 
    \item Damit nicht alle Slots geladen werden müssen (z.B. für Menu wo eine Liste der Slots angezeigt werden soll) werden die Daten in zwei Bereiche gespeichert:
    \begin{itemize}
        \item Slot Info (Leichtgewichtete Daten über das Spiel, wie Player Level, XP, Spielername, ...)
        \item Slot Data (Alle Informationen der serialisierten Actors und Components eines Spieles)
    \end{itemize}
    \item Auto-Save (Speichern des aktuellen Slots) und Auto-Load (Laden des letzten aktiven Slots)
    \item Asynchrone Features:
    \begin{itemize}
        \item Multithreaded Serialisierung
        \item Multithreaded Dateien (Dateien werden im Hintergrund komprimiert und gespeichert/geladen)
    \end{itemize} 
    \item Wenn Sublevels entladen werden, werden Daten dieser zwischengespeichert (Cache) und beim laden dieser Sublevels wieder wiederhergestellt
    \item Speicher Prozess (Bild zu Zuständen in Doku):
    \begin{enumerate}
        \item Alten Spielstand löschen
        \item OnSaveBegan aufrufen
        \item Thumbnail und Stats speichern
        \item Welt serialisieren
        \item OnSaveFinished aufrufen
    \end{enumerate}
    \item Lade Prozess (Bild zu Zuständen in Doku):
    \begin{enumerate}
        \item OnLoadBegan aufrufen
        \item Maps und Daten laden
        \item Bake Filters (Alle Level Filter und genereller Filter baken -> Damit überprüft wird welcher Actor in jedem Level vorbereitet werden muss und wie dieser deserialisiert wird)
        \item Levels vorbereiten (Gespeicherte Actors wiederherstellen und Actors die nicht existiert haben sollten löschen)
        \item Welt deserialisieren (Durch alle Levels durchgehen und alle Actor und seine Components deserialisieren)
    \end{enumerate}
\end{itemize}

% 10.7.
\url{https://www.unrealengine.com/marketplace/en-US/product/save-extension}\\
\url{https://piperift.com/SaveExtension/#/}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Godot}
Godot Engine grob vorstellen und erklären

\subsection{JSON}
Macht viel Sinn, weil GodotScript Dictionaries hat, die Sachen wie im JSON Stil speichern 
können. JSON wird dann zu einem Dictionary umgeformt und ein Dictionary in JSON

\begin{itemize}
    \item Daten in dictionary abspeichern
    \item Dictionary zu JSON-String serialisieren mit Godot Hilfsklasse JSON
    \item Manche Datentypen wie Vector2 können nicht serialisiert werden
\end{itemize}

% 10.7.
\url{https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html}\\

\subsection{Binary Serialization}

\begin{itemize}
    \item Umwandeln von Datentypen zu array von bytes
    \item Godot bietet 30 Datentypen an, die in binären Format gespeichert werden können
    \item Jedes Packet (Datentyp) hat folgende bytes:
    \begin{itemize}
        \item 4-byte header um den Typen zu definieren (0 = null, 1 = bool, 2 = integer, ...) und zum setzen von flags
        \item Packetinhalt(e), der ab dem 5. Byte anfängt und unterschiedlich groß ist 
    \end{itemize}
\end{itemize}

% 10.7.
\url{https://docs.godotengine.org/en/stable/tutorials/io/binary_serialization_api.html}

\subsection{Universal Save/Load System}
% 10.7.
\url{https://godotengine.org/asset-library/asset/1655}\\
\url{https://stupidratstudio.github.io/thoth/}