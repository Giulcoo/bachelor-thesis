Index: app/src/main/java/strategies/service/ChunkService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package strategies.service;\r\n\r\nimport strategies.Constants;\r\nimport strategies.model.*;\r\nimport strategies.model.Character;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class ChunkService {\r\n    private final ChangeTracker changeTracker;\r\n    private final List<Chunk<Character>> characterChunks = new ArrayList<>();\r\n    private final List<Chunk<Item>> itemChunks = new ArrayList<>();\r\n    private final List<Chunk<Obstacle>> obstacleChunks = new ArrayList<>();\r\n\r\n    public ChunkService(ChangeTracker changeTracker) {\r\n        this.changeTracker = changeTracker;\r\n        characterChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));\r\n        itemChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));\r\n        obstacleChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));\r\n    }\r\n\r\n    public void addElement(Character element){\r\n        for(int i = 0; i < characterChunks.size(); i++){\r\n            Chunk<Character> chunk = characterChunks.get(i);\r\n            if(chunk.pointInChunk(element)){\r\n                chunk.addElement(element);\r\n                changeTracker.addCharacterChange(chunk);\r\n\r\n                List<Chunk<Character>> newChunks = chunk.checkChunkSize();\r\n                newChunks.forEach(changeTracker::addCharacterChange);\r\n                characterChunks.addAll(newChunks);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addElement(Item element){\r\n        for(int i = 0; i < itemChunks.size(); i++){\r\n            Chunk<Item> chunk = itemChunks.get(i);\r\n            if(chunk.pointInChunk(element)){\r\n                chunk.addElement(element);\r\n                changeTracker.addItemChange(chunk);\r\n\r\n                List<Chunk<Item>> newChunks = chunk.checkChunkSize();\r\n                newChunks.forEach(changeTracker::addItemChange);\r\n                itemChunks.addAll(newChunks);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addElement(Obstacle element){\r\n        for(int i = 0; i < obstacleChunks.size(); i++){\r\n            Chunk<Obstacle> chunk = obstacleChunks.get(i);\r\n            if(chunk.pointInChunk(element)){\r\n                chunk.addElement(element);\r\n                changeTracker.addObstacleChange(chunk);\r\n\r\n                List<Chunk<Obstacle>> newChunks = chunk.checkChunkSize();\r\n                newChunks.forEach(changeTracker::addObstacleChange);\r\n                obstacleChunks.addAll(newChunks);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void removeElement(Character element){\r\n        changeTracker.addCharacterChange(element.getChunk());\r\n        element.getChunk().removeElement(element);\r\n    }\r\n\r\n    public void removeElement(Item element){\r\n        changeTracker.addItemChange(element.getChunk());\r\n        element.getChunk().removeElement(element);\r\n    }\r\n\r\n    public void updateElement(Character element){\r\n        Chunk<Character> currentChunk = element.getChunk();\r\n        if(currentChunk.pointInChunk(element)) return;\r\n\r\n        for(Chunk<Character> c : currentChunk.getNeighbours()){\r\n            if(c.pointInChunk(element)){\r\n                changeTracker.addCharacterChange(currentChunk);\r\n                currentChunk.removeElement(element);\r\n\r\n                c.addElement(element);\r\n                changeTracker.addCharacterChange(c);\r\n\r\n                List<Chunk<Character>> newChunks = c.checkChunkSize();\r\n                newChunks.forEach(changeTracker::addCharacterChange);\r\n                characterChunks.addAll(newChunks);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    public void updateElement(Item element){\r\n        Chunk<Item> currentChunk = element.getChunk();\r\n        if(currentChunk.pointInChunk(element)) return;\r\n\r\n        for(Chunk<Item> c : currentChunk.getNeighbours()){\r\n            if(c.pointInChunk(element)){\r\n                changeTracker.addItemChange(currentChunk);\r\n                currentChunk.removeElement(element);\r\n\r\n                c.addElement(element);\r\n                changeTracker.addItemChange(c);\r\n\r\n                List<Chunk<Item>> newChunks = c.checkChunkSize();\r\n                newChunks.forEach(changeTracker::addItemChange);\r\n                itemChunks.addAll(newChunks);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void printChunks(){\r\n        System.out.println(\"Character chunks:\");\r\n        int index = 0;\r\n        for(Chunk<Character> c : characterChunks){\r\n            System.out.println(\"Chunk \" + index + \":\");\r\n            System.out.println(c);\r\n            System.out.println();\r\n            index++;\r\n        }\r\n\r\n        System.out.println(\"Item chunks:\");\r\n        index = 0;\r\n        for(Chunk<Item> c : itemChunks){\r\n            System.out.println(\"Chunk \" + index + \":\");\r\n            System.out.println(c);\r\n            System.out.println();\r\n            index++;\r\n        }\r\n\r\n        System.out.println(\"Obstacle chunks:\");\r\n        index = 0;\r\n        for(Chunk<Obstacle> c : obstacleChunks){\r\n            System.out.println(\"Chunk \" + index + \":\");\r\n            System.out.println(c);\r\n            System.out.println();\r\n            index++;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/strategies/service/ChunkService.java b/app/src/main/java/strategies/service/ChunkService.java
--- a/app/src/main/java/strategies/service/ChunkService.java	(revision 432fd31544970ecf12b1b3c11fc432574b302d60)
+++ b/app/src/main/java/strategies/service/ChunkService.java	(date 1686315223321)
@@ -16,9 +16,9 @@
 
     public ChunkService(ChangeTracker changeTracker) {
         this.changeTracker = changeTracker;
-        characterChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
-        itemChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
-        obstacleChunks.add(new Chunk<>(new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
+        characterChunks.add(new Chunk<>(null, new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
+        itemChunks.add(new Chunk<>(null, new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
+        obstacleChunks.add(new Chunk<>(null, new Vector(0, 0, 0), new Vector(Constants.MAP_SIZE, Constants.MAP_SIZE, 0)));
     }
 
     public void addElement(Character element){
@@ -28,9 +28,15 @@
                 chunk.addElement(element);
                 changeTracker.addCharacterChange(chunk);
 
-                List<Chunk<Character>> newChunks = chunk.checkChunkSize();
-                newChunks.forEach(changeTracker::addCharacterChange);
-                characterChunks.addAll(newChunks);
+                int sizeCheckResult = chunk.checkChunkSize();
+                if(sizeCheckResult == 1){
+                    chunk.getChildChunks().forEach(changeTracker::addCharacterChange);
+                    characterChunks.addAll(chunk.getChildChunks());
+                }
+                else if(sizeCheckResult == -1){
+                    //TODO: changeTracker removedChunk
+                }
+
                 break;
             }
         }
Index: app/src/main/java/strategies/model/Chunk.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package strategies.model;\r\n\r\nimport java.sql.SQLOutput;\r\nimport java.util.*;\r\n\r\npublic class Chunk<T> {\r\n    private final List<T> elements;\r\n    private final String id;\r\n    private final static int CHUNK_SIZE_LIMIT = 100;\r\n\r\n    private final List<Chunk<T>> topChunks;\r\n\r\n    private final List<Chunk<T>> leftChunks;\r\n\r\n    private final List<Chunk<T>> rightChunks;\r\n\r\n    private final List<Chunk<T>> bottomChunks;\r\n\r\n    private Vector center;\r\n    private Vector size;\r\n\r\n    public Chunk(Vector center, Vector size) {\r\n        this.id = UUID.randomUUID().toString();\r\n        this.center = center;\r\n        this.size = size;\r\n        this.elements = new ArrayList<>();\r\n        this.topChunks = new ArrayList<>();\r\n        this.leftChunks = new ArrayList<>();\r\n        this.rightChunks = new ArrayList<>();\r\n        this.bottomChunks = new ArrayList<>();\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public List<T> getElements() {\r\n        return elements;\r\n    }\r\n\r\n    public Chunk addElement(T element){\r\n        if(element instanceof Item) ((Item) element).setChunk((Chunk<Item>) this);\r\n        else if(element instanceof Character) ((Character) element).setChunk((Chunk<Character>) this);\r\n        elements.add(element);\r\n        return this;\r\n    }\r\n\r\n    public Chunk addElements(List<T> elements){\r\n        elements.forEach(this::addElement);\r\n        return this;\r\n    }\r\n\r\n    public Chunk removeElement(T element){\r\n        elements.remove(element);\r\n        if(element instanceof Item) ((Item) element).setChunk(null);\r\n        else if(element instanceof Character) ((Character) element).setChunk(null);\r\n        return this;\r\n    }\r\n\r\n    public Chunk setNeighbours(List<Chunk<T>> topChunks, List<Chunk<T>> leftChunks, List<Chunk<T>> rightChunks, List<Chunk<T>> bottomChunks){\r\n        this.topChunks.addAll(topChunks);\r\n        this.leftChunks.addAll(leftChunks);\r\n        this.rightChunks.addAll(rightChunks);\r\n        this.bottomChunks.addAll(bottomChunks);\r\n        return this;\r\n    }\r\n\r\n    public List<Chunk<T>> getNeighbours(){\r\n        List<Chunk<T>> result = new ArrayList<>();\r\n        result.addAll(topChunks);\r\n        result.addAll(leftChunks);\r\n        result.addAll(rightChunks);\r\n        result.addAll(bottomChunks);\r\n        return result;\r\n    }\r\n\r\n    public List<Chunk<T>> checkChunkSize(){\r\n        return elements.size() > CHUNK_SIZE_LIMIT ? splitChunk() : new ArrayList<>();\r\n    }\r\n\r\n    private List<Chunk<T>> splitChunk(){\r\n        List<T> elementsCopy = new ArrayList<>(this.elements);\r\n        this.elements.clear();\r\n\r\n        Vector newSize = new Vector(size.getX()/2,size.getY()/2,0);\r\n\r\n        List<Chunk<T>> result = new ArrayList<>();\r\n        result.add(new Chunk<T>(new Vector(center.getX() - newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));\r\n        result.add(new Chunk<T>(new Vector(center.getX() + newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));\r\n        result.add(new Chunk<T>(new Vector(center.getX() - newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));\r\n        result.add(new Chunk<T>(new Vector(center.getX() + newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));\r\n\r\n        elementsCopy.forEach(e -> {\r\n            for(Chunk c : result){\r\n                if(c.pointInChunk(e)){\r\n                    c.addElement(e);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n\r\n        result.get(0).setNeighbours(new ArrayList<>(topChunks), new ArrayList<>(leftChunks), Arrays.asList(result.get(1)), Arrays.asList(result.get(2)));\r\n        result.get(1).setNeighbours(new ArrayList<>(topChunks), Arrays.asList(result.get(0)), new ArrayList<>(rightChunks), Arrays.asList(result.get(3)));\r\n        result.get(2).setNeighbours(Arrays.asList(result.get(0)), new ArrayList<>(leftChunks), Arrays.asList(result.get(3)), new ArrayList<>(bottomChunks));\r\n        this.setNeighbours(Arrays.asList(result.get(1)), Arrays.asList(result.get(2)), new ArrayList<>(rightChunks), new ArrayList<>(bottomChunks));\r\n\r\n        this.elements.addAll(result.get(3).elements);\r\n        this.center = result.get(3).center;\r\n        this.size = result.get(3).size;\r\n\r\n        result.remove(3);\r\n        return result;\r\n    }\r\n\r\n    public boolean pointInChunk(Object o){\r\n        Vector position = null;\r\n        if (o instanceof Character) {\r\n            position = ((Character) o).getPosition();\r\n        } else if (o instanceof Item) {\r\n            position = ((Item) o).getPosition();\r\n        } else if (o instanceof Obstacle) {\r\n            position = ((Obstacle) o).getPosition();\r\n        }\r\n\r\n        return position != null\r\n                && Math.abs(position.getX() - center.getX()) <= size.getX() / 2\r\n                && Math.abs(position.getY() - center.getY()) <= size.getY() / 2;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String result = \"Position: \" + center + \" Size: \" + size + \"\\nElemenst:\\n\";\r\n        for(T element : elements){\r\n            result += element.toString() + \"\\n\";\r\n        }\r\n        return result;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/strategies/model/Chunk.java b/app/src/main/java/strategies/model/Chunk.java
--- a/app/src/main/java/strategies/model/Chunk.java	(revision 432fd31544970ecf12b1b3c11fc432574b302d60)
+++ b/app/src/main/java/strategies/model/Chunk.java	(date 1686315296646)
@@ -4,36 +4,50 @@
 import java.util.*;
 
 public class Chunk<T> {
+    private final static int CHUNK_SIZE_LIMIT = 100;
+    private final static int CHUNK_GROUP_SIZE_MIN = 10;
+    private final String id;
     private final List<T> elements;
-    private final String id;
-    private final static int CHUNK_SIZE_LIMIT = 100;
 
-    private final List<Chunk<T>> topChunks;
+    private final Chunk<T> parentChunk;
+    private final List<Chunk<T>> childChunks;
+
+    /*private final List<Chunk<T>> topChunks;
 
     private final List<Chunk<T>> leftChunks;
 
     private final List<Chunk<T>> rightChunks;
 
-    private final List<Chunk<T>> bottomChunks;
+    private final List<Chunk<T>> bottomChunks;*/
 
     private Vector center;
     private Vector size;
 
-    public Chunk(Vector center, Vector size) {
+    public Chunk(Chunk<T> parentChunk, Vector center, Vector size) {
         this.id = UUID.randomUUID().toString();
         this.center = center;
         this.size = size;
         this.elements = new ArrayList<>();
-        this.topChunks = new ArrayList<>();
+        this.parentChunk = parentChunk;
+        this.childChunks = new ArrayList<>();
+        /*this.topChunks = new ArrayList<>();
         this.leftChunks = new ArrayList<>();
         this.rightChunks = new ArrayList<>();
-        this.bottomChunks = new ArrayList<>();
+        this.bottomChunks = new ArrayList<>();*/
     }
 
     public String getId() {
         return id;
     }
 
+    public Chunk<T> getParent(){
+        return parentChunk;
+    }
+
+    public List<Chunk<T>> getChildChunks(){
+        return childChunks;
+    }
+
     public List<T> getElements() {
         return elements;
     }
@@ -57,7 +71,7 @@
         return this;
     }
 
-    public Chunk setNeighbours(List<Chunk<T>> topChunks, List<Chunk<T>> leftChunks, List<Chunk<T>> rightChunks, List<Chunk<T>> bottomChunks){
+    /*public Chunk setNeighbours(List<Chunk<T>> topChunks, List<Chunk<T>> leftChunks, List<Chunk<T>> rightChunks, List<Chunk<T>> bottomChunks){
         this.topChunks.addAll(topChunks);
         this.leftChunks.addAll(leftChunks);
         this.rightChunks.addAll(rightChunks);
@@ -72,24 +86,43 @@
         result.addAll(rightChunks);
         result.addAll(bottomChunks);
         return result;
-    }
+    }*/
+
+    /**
+     Checks if a chunk has to be split or joined
+     @return -1 if the chunk was joined<br>1 &nbsp;if the chunk was splitted<br>0 &nbsp;if nothing happened
+     */
+    public int checkChunkSize(){
+        //TODO: Do this check in parent not in this chunk
+        if(!childChunks.isEmpty() && childChunks.stream().mapToInt(c -> c.elements.size()).sum() < CHUNK_GROUP_SIZE_MIN){
+            joinChunk();
+            return -1;
+        }
+
+        if(elements.size() > CHUNK_SIZE_LIMIT){
+            splitChunk();
+            return 1;
+        }
 
-    public List<Chunk<T>> checkChunkSize(){
-        return elements.size() > CHUNK_SIZE_LIMIT ? splitChunk() : new ArrayList<>();
+        return 0;
+
+        //return elements.size() > CHUNK_SIZE_LIMIT ? splitChunk() : 0;
     }
 
-    private List<Chunk<T>> splitChunk(){
+    private void splitChunk(){
         List<T> elementsCopy = new ArrayList<>(this.elements);
         this.elements.clear();
 
         Vector newSize = new Vector(size.getX()/2,size.getY()/2,0);
 
         List<Chunk<T>> result = new ArrayList<>();
-        result.add(new Chunk<T>(new Vector(center.getX() - newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));
-        result.add(new Chunk<T>(new Vector(center.getX() + newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));
-        result.add(new Chunk<T>(new Vector(center.getX() - newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));
-        result.add(new Chunk<T>(new Vector(center.getX() + newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));
+        result.add(new Chunk<T>(this, new Vector(center.getX() - newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));
+        result.add(new Chunk<T>(this, new Vector(center.getX() + newSize.getX()/2,center.getY() - newSize.getY()/2,0), newSize));
+        result.add(new Chunk<T>(this, new Vector(center.getX() - newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));
+        result.add(new Chunk<T>(this, new Vector(center.getX() + newSize.getX()/2,center.getY() + newSize.getY()/2,0), newSize));
+        this.childChunks.addAll(result);
 
+        //Split chunk elements in new chunks
         elementsCopy.forEach(e -> {
             for(Chunk c : result){
                 if(c.pointInChunk(e)){
@@ -99,7 +132,7 @@
             }
         });
 
-        result.get(0).setNeighbours(new ArrayList<>(topChunks), new ArrayList<>(leftChunks), Arrays.asList(result.get(1)), Arrays.asList(result.get(2)));
+       /* result.get(0).setNeighbours(new ArrayList<>(topChunks), new ArrayList<>(leftChunks), Arrays.asList(result.get(1)), Arrays.asList(result.get(2)));
         result.get(1).setNeighbours(new ArrayList<>(topChunks), Arrays.asList(result.get(0)), new ArrayList<>(rightChunks), Arrays.asList(result.get(3)));
         result.get(2).setNeighbours(Arrays.asList(result.get(0)), new ArrayList<>(leftChunks), Arrays.asList(result.get(3)), new ArrayList<>(bottomChunks));
         this.setNeighbours(Arrays.asList(result.get(1)), Arrays.asList(result.get(2)), new ArrayList<>(rightChunks), new ArrayList<>(bottomChunks));
@@ -107,9 +140,31 @@
         this.elements.addAll(result.get(3).elements);
         this.center = result.get(3).center;
         this.size = result.get(3).size;
-
         result.remove(3);
-        return result;
+        return result;*/
+    }
+
+    private void joinChunk(){
+        this.childChunks.forEach(c -> {
+            this.addElements(c.elements);
+            c.elements.clear();
+        });
+    }
+
+    public Chunk findChunk(Object o){
+        if(pointInChunk(o)){
+            if(childChunks.isEmpty()) return this;
+            else{
+                for(Chunk c : childChunks){
+                    if(c.pointInChunk(o)){
+                        Chunk result = c.findChunk(o);
+                        if(result != null) return result;
+                    }
+                }
+            }
+        }
+
+        return this.parentChunk.findChunk(o);
     }
 
     public boolean pointInChunk(Object o){
